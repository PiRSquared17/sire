// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 2 License

#include "boost/python.hpp"
#include "MutexLocker.pypp.hpp"

namespace bp = boost::python;

#include "forages.h"

#include "mutex.h"

#include "mutex.h"

const char* pvt_get_name(const Siren::MutexLocker&){ return "Siren::MutexLocker";}

void register_MutexLocker_class(){

    { //::Siren::MutexLocker
        typedef bp::class_< Siren::MutexLocker, boost::noncopyable > MutexLocker_exposer_t;
        MutexLocker_exposer_t MutexLocker_exposer = MutexLocker_exposer_t( "MutexLocker", bp::no_init );
        bp::scope MutexLocker_scope( MutexLocker_exposer );
        { //::Siren::MutexLocker::relock
        
            typedef void ( ::Siren::MutexLocker::*relock_function_type )(  ) ;
            relock_function_type relock_function_value( &::Siren::MutexLocker::relock );
            
            MutexLocker_exposer.def( 
                "relock"
                , relock_function_value );
        
        }
        { //::Siren::MutexLocker::unlock
        
            typedef void ( ::Siren::MutexLocker::*unlock_function_type )(  ) ;
            unlock_function_type unlock_function_value( &::Siren::MutexLocker::unlock );
            
            MutexLocker_exposer.def( 
                "unlock"
                , unlock_function_value );
        
        }
        MutexLocker_exposer.def( "__str__", &pvt_get_name);
        MutexLocker_exposer.def( "__repr__", &pvt_get_name);
    }

}
