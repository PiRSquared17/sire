// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 2 License

#include "boost/python.hpp"
#include "IndexList.pypp.hpp"

namespace bp = boost::python;

#include "SireError/errors.h"

#include "SireSim/dimensions.hpp"

#include "SireSim/indexvalue.h"

#include "indexvalue.h"

#include <QDebug>

#include <QDomDocument>

#include <QPair>

#include "indexvalue.h"

SireSim::IndexList __copy__(const SireSim::IndexList &other){ return SireSim::IndexList(other); }

#include "Helpers/str.hpp"

void register_IndexList_class(){

    { //::SireSim::IndexList
        typedef bp::class_< SireSim::IndexList, bp::bases< SireSim::Value > > IndexList_exposer_t;
        IndexList_exposer_t IndexList_exposer = IndexList_exposer_t( "IndexList", bp::init< >() );
        bp::scope IndexList_scope( IndexList_exposer );
        IndexList_exposer.def( bp::init< int >(( bp::arg("index") )) );
        IndexList_exposer.def( bp::init< int, int, bp::optional< int > >(( bp::arg("start"), bp::arg("end"), bp::arg("jump")=(int)(1) )) );
        IndexList_exposer.def( bp::init< SireSim::Range >(( bp::arg("range") )) );
        IndexList_exposer.def( bp::init< QList< int >, bp::optional< bool > >(( bp::arg("indicies"), bp::arg("allow_duplicates")=(bool)(true) )) );
        IndexList_exposer.def( bp::init< QList< SireSim::Range >, bp::optional< bool > >(( bp::arg("indices"), bp::arg("allow_duplicates")=(bool)(true) )) );
        IndexList_exposer.def( bp::init< QString, bp::optional< bool > >(( bp::arg("indicies"), bp::arg("allow_duplicates")=(bool)(true) )) );
        IndexList_exposer.def( bp::init< QDomElement >(( bp::arg("elem") )) );
        IndexList_exposer.def( bp::init< SireSim::IndexList const & >(( bp::arg("other") )) );
        { //::SireSim::IndexList::allowDuplicates
        
            typedef bool ( ::SireSim::IndexList::*allowDuplicates_function_type )(  ) const;
            allowDuplicates_function_type allowDuplicates_function_value( &::SireSim::IndexList::allowDuplicates );
            
            IndexList_exposer.def( 
                "allowDuplicates"
                , allowDuplicates_function_value );
        
        }
        { //::SireSim::IndexList::at
        
            typedef int ( ::SireSim::IndexList::*at_function_type )( int,int ) const;
            at_function_type at_function_value( &::SireSim::IndexList::at );
            
            IndexList_exposer.def( 
                "at"
                , at_function_value
                , ( bp::arg("i"), bp::arg("nvalues") ) );
        
        }
        { //::SireSim::IndexList::count
        
            typedef int ( ::SireSim::IndexList::*count_function_type )( int ) const;
            count_function_type count_function_value( &::SireSim::IndexList::count );
            
            IndexList_exposer.def( 
                "count"
                , count_function_value
                , ( bp::arg("nvalues") ) );
        
        }
        { //::SireSim::IndexList::count
        
            typedef int ( ::SireSim::IndexList::*count_function_type )( int,int,int ) const;
            count_function_type count_function_value( &::SireSim::IndexList::count );
            
            IndexList_exposer.def( 
                "count"
                , count_function_value
                , ( bp::arg("i"), bp::arg("nvalues"), bp::arg("batchsize")=(int)(1000) ) );
        
        }
        { //::SireSim::IndexList::indicies
        
            typedef ::QList< int > ( ::SireSim::IndexList::*indicies_function_type )( int ) const;
            indicies_function_type indicies_function_value( &::SireSim::IndexList::indicies );
            
            IndexList_exposer.def( 
                "indicies"
                , indicies_function_value
                , ( bp::arg("nvalues") ) );
        
        }
        { //::SireSim::IndexList::indicies
        
            typedef ::QList< int > ( ::SireSim::IndexList::*indicies_function_type )( int,int,int ) const;
            indicies_function_type indicies_function_value( &::SireSim::IndexList::indicies );
            
            IndexList_exposer.def( 
                "indicies"
                , indicies_function_value
                , ( bp::arg("i"), bp::arg("nvalues"), bp::arg("batchsize")=(int)(1000) ) );
        
        }
        { //::SireSim::IndexList::nBatches
        
            typedef int ( ::SireSim::IndexList::*nBatches_function_type )( int,int ) const;
            nBatches_function_type nBatches_function_value( &::SireSim::IndexList::nBatches );
            
            IndexList_exposer.def( 
                "nBatches"
                , nBatches_function_value
                , ( bp::arg("nvalues"), bp::arg("batchsize")=(int)(1000) ) );
        
        }
        IndexList_exposer.def( bp::self != bp::self );
        { //::SireSim::IndexList::operator=
        
            typedef ::SireSim::IndexList & ( ::SireSim::IndexList::*assign_function_type )( ::SireSim::IndexList const & ) ;
            assign_function_type assign_function_value( &::SireSim::IndexList::operator= );
            
            IndexList_exposer.def( 
                "assign"
                , assign_function_value
                , ( bp::arg("other") )
                , bp::return_self< >() );
        
        }
        IndexList_exposer.def( bp::self == bp::self );
        { //::SireSim::IndexList::typeName
        
            typedef char const * ( *typeName_function_type )(  );
            typeName_function_type typeName_function_value( &::SireSim::IndexList::typeName );
            
            IndexList_exposer.def( 
                "typeName"
                , typeName_function_value );
        
        }
        { //::SireSim::IndexList::what
        
            typedef char const * ( ::SireSim::IndexList::*what_function_type )(  ) const;
            what_function_type what_function_value( &::SireSim::IndexList::what );
            
            IndexList_exposer.def( 
                "what"
                , what_function_value );
        
        }
        IndexList_exposer.staticmethod( "typeName" );
        IndexList_exposer.def( "__copy__", &__copy__);
        IndexList_exposer.def( "__deepcopy__", &__copy__);
        IndexList_exposer.def( "clone", &__copy__);
        IndexList_exposer.def( "__str__", &__str__< ::SireSim::IndexList > );
        IndexList_exposer.def( "__repr__", &__str__< ::SireSim::IndexList > );
    }

}
