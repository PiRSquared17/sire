// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 2 License

#include "boost/python.hpp"
#include "Mutable.pypp.hpp"

namespace bp = boost::python;

#include "mutable.h"

#include "mutable.h"

#include "object.h"

#include "objref.h"

#include "tester.h"

#include "logger.h"

const char* pvt_get_name(const Siren::Mutable&){ return "Siren::Mutable";}

void register_Mutable_class(){

    { //::Siren::Mutable
        typedef bp::class_< Siren::Mutable, boost::noncopyable > Mutable_exposer_t;
        Mutable_exposer_t Mutable_exposer = Mutable_exposer_t( "Mutable", bp::no_init );
        bp::scope Mutable_scope( Mutable_exposer );
        { //::Siren::Mutable::restoreState
        
            typedef void ( ::Siren::Mutable::*restoreState_function_type )( ::Siren::Object const & ) ;
            restoreState_function_type restoreState_function_value( &::Siren::Mutable::restoreState );
            
            Mutable_exposer.def( 
                "restoreState"
                , restoreState_function_value
                , ( bp::arg("object") ) );
        
        }
        { //::Siren::Mutable::saveState
        
            typedef ::Siren::ObjRef ( ::Siren::Mutable::*saveState_function_type )(  ) const;
            saveState_function_type saveState_function_value( &::Siren::Mutable::saveState );
            
            Mutable_exposer.def( 
                "saveState"
                , saveState_function_value );
        
        }
        { //::Siren::Mutable::typeName
        
            typedef ::QString ( *typeName_function_type )(  );
            typeName_function_type typeName_function_value( &::Siren::Mutable::typeName );
            
            Mutable_exposer.def( 
                "typeName"
                , typeName_function_value );
        
        }
        Mutable_exposer.staticmethod( "typeName" );
        Mutable_exposer.def( "__str__", &pvt_get_name);
        Mutable_exposer.def( "__repr__", &pvt_get_name);
    }

}
