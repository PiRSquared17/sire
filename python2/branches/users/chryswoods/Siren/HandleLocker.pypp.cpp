// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 2 License

#include "boost/python.hpp"
#include "HandleLocker.pypp.hpp"

namespace bp = boost::python;

#include "Siren/errors.h"

#include "class.h"

#include "handle.h"

#include "hanref.h"

#include "logger.h"

#include "waitcondition.h"

#include "handle.h"

#include "Siren/logger.h"

const char* pvt_get_name(const Siren::HandleLocker&){ return "Siren::HandleLocker";}

void register_HandleLocker_class(){

    { //::Siren::HandleLocker
        typedef bp::class_< Siren::HandleLocker, boost::noncopyable > HandleLocker_exposer_t;
        HandleLocker_exposer_t HandleLocker_exposer = HandleLocker_exposer_t( "HandleLocker" );
        bp::scope HandleLocker_scope( HandleLocker_exposer );
        { //::Siren::HandleLocker::relock
        
            typedef void ( ::Siren::HandleLocker::*relock_function_type )(  ) ;
            relock_function_type relock_function_value( &::Siren::HandleLocker::relock );
            
            HandleLocker_exposer.def( 
                "relock"
                , relock_function_value );
        
        }
        { //::Siren::HandleLocker::unlock
        
            typedef void ( ::Siren::HandleLocker::*unlock_function_type )(  ) ;
            unlock_function_type unlock_function_value( &::Siren::HandleLocker::unlock );
            
            HandleLocker_exposer.def( 
                "unlock"
                , unlock_function_value );
        
        }
        HandleLocker_exposer.def( "__str__", &pvt_get_name);
        HandleLocker_exposer.def( "__repr__", &pvt_get_name);
    }

}
