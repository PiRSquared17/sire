// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 2 License

#include "boost/python.hpp"
#include "Key.pypp.hpp"

namespace bp = boost::python;

#include "SireSec/errors.h"

#include "Siren/stream.h"

#include "key.h"

#include "key.h"

#include "Siren/logger.h"

#include "Siren/str.hpp"

void register_Key_class(){

    { //::SireSec::Key
        typedef bp::class_< SireSec::Key, bp::bases< Siren::Object >, boost::noncopyable > Key_exposer_t;
        Key_exposer_t Key_exposer = Key_exposer_t( "Key", bp::no_init );
        bp::scope Key_scope( Key_exposer );
        bp::enum_< SireSec::Key::Option>("Option")
            .value("Unrestricted", SireSec::Key::Unrestricted)
            .value("NonStreamable", SireSec::Key::NonStreamable)
            .value("LockedToThread", SireSec::Key::LockedToThread)
            .export_values()
            ;
        { //::SireSec::Key::assertAvailableToThisThread
        
            typedef void ( ::SireSec::Key::*assertAvailableToThisThread_function_type )(  ) const;
            assertAvailableToThisThread_function_type assertAvailableToThisThread_function_value( &::SireSec::Key::assertAvailableToThisThread );
            
            Key_exposer.def( 
                "assertAvailableToThisThread"
                , assertAvailableToThisThread_function_value );
        
        }
        { //::SireSec::Key::assertIsStreamable
        
            typedef void ( ::SireSec::Key::*assertIsStreamable_function_type )(  ) const;
            assertIsStreamable_function_type assertIsStreamable_function_value( &::SireSec::Key::assertIsStreamable );
            
            Key_exposer.def( 
                "assertIsStreamable"
                , assertIsStreamable_function_value );
        
        }
        { //::SireSec::Key::availableToThisThread
        
            typedef bool ( ::SireSec::Key::*availableToThisThread_function_type )(  ) const;
            availableToThisThread_function_type availableToThisThread_function_value( &::SireSec::Key::availableToThisThread );
            
            Key_exposer.def( 
                "availableToThisThread"
                , availableToThisThread_function_value );
        
        }
        { //::SireSec::Key::bestBefore
        
            typedef ::QDateTime ( ::SireSec::Key::*bestBefore_function_type )(  ) const;
            bestBefore_function_type bestBefore_function_value( &::SireSec::Key::bestBefore );
            
            Key_exposer.def( 
                "bestBefore"
                , bestBefore_function_value );
        
        }
        { //::SireSec::Key::isExpired
        
            typedef bool ( ::SireSec::Key::*isExpired_function_type )(  ) const;
            isExpired_function_type isExpired_function_value( &::SireSec::Key::isExpired );
            
            Key_exposer.def( 
                "isExpired"
                , isExpired_function_value );
        
        }
        { //::SireSec::Key::isLockedToThread
        
            typedef bool ( ::SireSec::Key::*isLockedToThread_function_type )(  ) const;
            isLockedToThread_function_type isLockedToThread_function_value( &::SireSec::Key::isLockedToThread );
            
            Key_exposer.def( 
                "isLockedToThread"
                , isLockedToThread_function_value );
        
        }
        { //::SireSec::Key::isStreamable
        
            typedef bool ( ::SireSec::Key::*isStreamable_function_type )(  ) const;
            isStreamable_function_type isStreamable_function_value( &::SireSec::Key::isStreamable );
            
            Key_exposer.def( 
                "isStreamable"
                , isStreamable_function_value );
        
        }
        { //::SireSec::Key::isTemporal
        
            typedef bool ( ::SireSec::Key::*isTemporal_function_type )(  ) const;
            isTemporal_function_type isTemporal_function_value( &::SireSec::Key::isTemporal );
            
            Key_exposer.def( 
                "isTemporal"
                , isTemporal_function_value );
        
        }
        { //::SireSec::Key::stream
        
            typedef void ( ::SireSec::Key::*stream_function_type )( ::Siren::Stream & ) ;
            stream_function_type stream_function_value( &::SireSec::Key::stream );
            
            Key_exposer.def( 
                "stream"
                , stream_function_value
                , ( bp::arg("s") ) );
        
        }
        { //::SireSec::Key::typeName
        
            typedef ::QString ( *typeName_function_type )(  );
            typeName_function_type typeName_function_value( &::SireSec::Key::typeName );
            
            Key_exposer.def( 
                "typeName"
                , typeName_function_value );
        
        }
        Key_exposer.staticmethod( "typeName" );
        Key_exposer.def( "__str__", &__str__< ::SireSec::Key > );
        Key_exposer.def( "__repr__", &__str__< ::SireSec::Key > );
    }

}
