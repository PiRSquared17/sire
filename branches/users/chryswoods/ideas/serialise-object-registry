Register all important objects with a registry...

registerType<BaseType, registerTraits<BaseType> >(const DerivedType &obj, const QString &name);

This creates two hashes for BaseType;

typeid_to_name - maps local typeid(obj).__name__ to passed QString &name

name_to_object - maps passed name to clone of the object

Can then do  QByteArray serialise<BaseType>(const DerivedType &obj);

This creates a QByteArray that contains 2 QByteArrays,

The first is the object description (name of object - obtained by looking up via

QString name = getRegisteredName<BaseType>(const DerivedType &obj)

  This uses typeid(obj) to get the internal name of the object, from which
  the user-supplied name can be looked up via the typeid_to_name hash
  
We can then serialise the object, and pack the serialised name, then serialised object
into a single QByteArray.

To extract, we can do;

boost::shared_ptr<BaseType> ptr = deserialise<BaseType, registerTraits<BaseType> >(QByteArray);

This unpacks the bytearray into the two bytearrays.

The first contains the name of the object. We look up the object in the name_to_object
hash, and we then clone the object that we find. Into this clone we then deserialise the 
other bytearray.

We then return the clone.

registerTraits<BaseType> is a traits class that can be specialised. This provides information
such as how to clone the object (which function to call), what pointer type is used and returned
(boost::shared_ptr, raw pointer or NetPtr for example), and what to do if the object is not
available in the name_to_object hash.

This class should be able to take on the role of all serialisation and deserialisation in the entire
program, both local and remote. It should also be able to replace the NetFactory, and the weird
registration that I use for the NetObjects, NetMessages and Invokers! 

Another advantage is that the order of registration is not important, and it can be dynamic, so
if an object is not registered, then a library could be loaded that contains the object, which 
can then register. This is the point of the traits class, that can contain additional code that
can take steps to register objects that are not registered. This means that remote processes 
don't need to register everything at the beginning, as they can register things as they 
go along. This makes the code a lot cleaner and more dynamic.

The only problem I can see so far is that I don't know how I could serialise objects that have 
been further derived in python. Admittedly, the remote processes aren't running python interpreters,
so couldn't run a python class anyway!
