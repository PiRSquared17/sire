star type communication for the most part, with communication initalised from the centre and propogated outwards.

thus it is a server to client setup.

two stage data send;

send 'info' object.
this contains information about the type of comminuication and the size
this is because mpi is very picky and needs total information

mpimsg
    type;
        enum: type of function to call
        type: type of the msgobj in the next receive
        int:  size of data in next receive
        unsigned long: id
        
e.g. 

type = close
size = 0
id = 0

just calls mpi finalize

type = clear
size = 0
id = 0

just clear the slave of all data

type = new simsys backend
size = size of bytearray
id = simsys id

    goes into a function that recieves the bytearray
    then constructs new simsys backend
    fills data for backend using buffer
    then uses identification of backend to place into a registry
   
type = update simsys backend
size = size of bytearray
id = simsys id

    goes into a function that recieves the bytearray
    then constructs a new simsys backend
    fills data for backend using buffer
    then uses identification of backend to update the one in the registry
    
no!

buffer contains much more complicated options that are best interpreted by the
object with the correct id

type = energy
size = 0
id = simsys id

this tells the slave to calculate the energy of this simsystem

type = getenergy
size = 0
id = simsys id

this tries to get the energy from this slave
the caller will block as it waits for a response from the receiver
the receiver will send back a result message that will contain the energy (ResultMsg)

type = isbusy
size = 0
id = simsys id

this asks whether the simsystem is busy
caller will block waiting for a BoolMsg from the receiver

Seem to be building a hierarchy of messages;

DoubleMsg
BoolMsg
BufferMsg
MainMsg

Create each type of message, and then each one has a 'send' and a 'receive' function
