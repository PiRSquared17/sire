
MyFFWrapper : public FFWrapper<FField>
{
    MyFFWrapper()
    {
        ptr = new MyFF();
        metadata = ptr.metadata();
    }
    
    void sendTo(Processor proc)
    {
        metadata.duplicate(proc);
        interface = ptr.metainfo().createInterface(proc);
        ptr.reset();
    }

    void setLocal()
    {
        ptr = metadata.getPtr();
        interface.reset();
        
        //update the ptr (closing the interface blocks until any
        //pending operations are complete
        ptr.update();
    }

    Result<Energy> energy()
    {
        if (not interface)
            return Result<Energy>(ptr->energy());
        else
            return interface->call(interface->CALL_ENERGY);
    }
    
    
    //using seperate interface allows versioning and code to do its best
    //to match versions (maintain backwards compatibility with remote
    //installations)
}

SpecificInterface : Interface

Result<nrg> energy()
{
    if (not pipe)
        return Result<nrg>( ptr<T>->energy() );
}

//use NetObject to create interfaces and invokers

boost::shared_ptr<Interface<FField> > NetObject<FField>::createInterface(MetaData &metadata, Processor Proc)
{
    //need to first create the invoker on the remote process
    pipe = createPipe(proc, metadata);
    
    //the invoker gets a pointer to the object, so it definitely creates the correct
    //invoker type. We now need to create the correct interface to this invoker
    InvokerMetaData metadata = pipe.invokerMetaData();
    
    //uses the metadata to match versions and type...
    return FFieldRegistry::createInterface(pipe);
}

InvokerPtr NetObject<FField>::createInvoker(MetaData &metadata)
{
    //get a Ptr<FField> to the object - this will only work if this object
    //exists on this processor
    Ptr<FField> ptr = metadata.getPtr();
    
    //now get the invoker for this object...
    return FFieldRegistry::createInvoker(ptr);
}


FFWrapperPtr FFieldRegistry::createInterface(pipe)
{
    InvokerMetaData metadata = pipe.invokerMetaData();
    
    //this contains the name of the invoker class - create the corresponding 
    //interface class
    
    //hash of invoker names (in app and all plugin libraries...)
    if (not interfaceregistry.contains(metadata.name()))
        throw unavailable_interface;
      
    InterfaceFunctions funcs = interfaceregistry[metadata.name()];
    
    if (not funcs.contains(metadata.version()))
    {
        //renegotiate with the pipe to find a matching version...
    
        //if still not happy, then throw an exception
        throw incompatible_version;
    }
    
    //ok - we have the function. Call the function to create the interface
    return funcs[metadata.version()]();
    
    //this return FFWrapperPtr to specific FFWrapper type
}

InvokerPtr FFieldRegistry::createInvoker(MetaData &metadata)
{
    //get the pointer...
    FFPtr ffield = metadata.getPtr();
    
    //get the name of the forcefield...
    QString ffname = ffield->type();

    //see if there is an invoker for this type
    if (not invokerregistry.contains(ffname))
        throw unavailable_invoker

    InvokerFunctions funcs = invokerregistry[ffname];
    
    //return the latest version invoker
    return funcs[last]();
}
