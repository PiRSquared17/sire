
Split program into multiple python modules
Have a NetServer module, so can query ProtoMS3 remotely


-----------------------------------------
C++ objects, but lots of C type functions, e.g.

*NO*  protein1.distance(solute1)

but rather  distance(protein1,solute1)

Still have protein, solute and solvent, but rename to 'ChainMol', 'FlexMol' and 'RigidMol', all of type 'Molecule'.

Molecule keeps all of its atoms in one big array, for efficiency.
Molecule is composed of CutGroups. A CutGroup is a group of atoms that are treated together
for the purposes of cutoffs. Thus RigidMol and FlexMol only consist of a single CutGroup, but
ChainMol is composed of a lot of CutGroups.

Can thus do;  energy(CutGroup1,CutGroup2) 
rather than;  energy(Chain,Flex), energy(Chain,Chain), energy(Flex,Rigid) etc.

Use pointers into big arrays to get data, e.g. coords are got via pointers into big coordinates array.

Use same sort of structure as ProtoMS 2.0, though use of objects should clean up a lot
of the helper functions that needed to be used.

Use energy objects to pass back energy components. Energy objects contain sub-energy objects that
actually contain the componenets, and flags to say whether they are deltas or totals.

Use energy master (with its own running thread) to accumalate the energies together into running
totals.

Make a threaded program from the start. Threads pass data to each other via caches that are
protected via mutexes. Can send 'flush' commands to caches to make sure that they are fully processed,
e.g.

energy cache:   nrg1  nrg2  nrg3  flush

will make energy master process 1, 2, 3, then resync the totals, (since flushed at end of move)

Use a flexible internal coordinate system (loosely based on zmatricies) to allow internal coordinate
based moves.

Build coordinates and structure separately from the energy routines and simulation routines.

Have a parallel design for the code all the way through. To calculate the energies we could have
a separate thread for each processor, push a CutGroup onto the 'stack' of each processor, push an
EnergyFunction onto each processor, and then run all of the other CutGroups through the processors in
parallel (since pairwise). Each processor will pass back some energy/force objects, that can be pushed onto
the energy cache for processing. Thus parallisation is read-only. (this would work well for MC, not for MD)

Need other parallisation schemes for other methods. Still try to keep split based on CutGroups, so that
it is possible to use the same EnergyFunction to do the work without needing to know how the parallisation
is working.

A System holds a complete system (molecules, size of box, temp, pressure, etc.)
A Simulation holds the System, indeed can hold multiple Systems. 

Code must be able to;

Perform MC
Perform MD

Work with several classical MM forcefields, AMBER/OPLS/CHARMM
Work with abinitio and semiempirical QM, and QM/MM

Implement the particle-mesh ewald sum!

QM parts separate from MM, with their own parallisation.

Need to have code to monitor how many processors are in use, how much memory is being used etc.
Memory manager will only monitor heap, not stack.

Write it to have a flexible interface - but with a ProtoMS 2.0 compatible front end (to ease testing).

This code will be designed to work with ATOMS. There will not be any abstraction that would allow
reduced representations or weird functions.

Will use rigid body MD for RigidMol rather than constraints!

Build it to use a plugin/library based design.

Have dependencies on LAPACK (for QM and other high level maths)
                     QT 3.0 (then 4.0) 
                     MPI    (for parallisation)
                     Python (for scripting)
                     
Beauty of C++ is can make it highly functional without loading much, as only load 
functionality as a library if we need it - thus only allocate what we need.
                     
Use general exceptions to drop us out, e.g. InvalidSystem, InvalidReference, IncompleteParameters, InvalidLine etc.
Most of these should take us back to where the system was loaded, so that it can be checked over for
what is wrong, and solutions if possible should be implemented.

Design it as a library - it should not crash itself!
