Problem is saving old coordinates as make new, and then restoring old if move failed.
Move can be very complicated, difficult to save.
Multi-part moves, e.g. MC between chunks of MD, multi-time-step MC etc.

It would be too expensive to save the state of the whole system as this would be very slow.

Possible solution would be to use checkpoints. Setting a checkpoint does not cost anything.
However, when we move or change a molecule, if there are any checkpoints, then we copy the 
old version of the molecule into the checkpoint. We only copy into a checkpoint if the molecule
who has not already been copied in. In this way, we can return to a prior version of the system
based on 'diffs' from the current version back to a previous version.

We could also have 'tags', which would represent a complete checkpoint of the entire system
(thus we could migrate from one system to another).


in simsystem, it sets a checkpoint for the original system
SimSystem::performMove(const Move &mov)
{
        ckpt = this->checkpoint();   ... checkpoint includes the nrg
        
        if (mov.move(this))
            this->commit();
        else
            this->revert();
}
        
MTS_MS_Move::move(SimSystem *sys)
{       

    //e.g. for MTS MC
    oldnrg = MTS_Forcefield.nrg(sys);
    
    for mov in moves
        mov.move(sys);


    //difficult...
}    

//clear all previous checkpoints, set a checkpoint to this revision
sys.commit()

sys.move()...
sys.move()...

//create a temporary checkpoint
sys.checkpoint()

sys.move()
sys.move()

if all passed
    //commit all of the moves!
    sys.commit()
else
    //revert to the last checkpoint
    sys.revert()
    
