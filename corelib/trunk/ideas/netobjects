
Have ProcessorRegistry object. Maps unique PID to processors (with their communication method, e.g. MPI proc 3).

ProcessorRegistry stored on master processor. NetObject, copies given to all processors that connect.

Giving of ProcessorRegistry last part of handshake.

Handshake involves comparing capabilities, e.g. which NetObjects do you support, and are they 
compatible versions?

Each processor will thus have up-to-date list of available processors, and methods of talking to them

Also, a processor can disconnect, then reconnect, and will retain its ID (as long as it keeps it).

To achieve this, each processor needs to be given a unique password tag, so that it can validate itself
when it reconnects.

Part of handshake could also be time synchronisation. Have time that processor 0 started as time 0.
Each processor then reports time as delta to time 0. Master processor can then convert these deltas 
back into real times from its own clock. That way, we don't rely on the clocks on the remote processors!

NetObjects can be placed in parent/child relationships. This allows Molecules to be added to a SimSystem
by using NetObjects pointers for the relationship.

Only one parent for each NetObject, so no double adding of molecules to different systems.

Also, if delegate power of a NetObject, then delegate power for all children, grandchildren etc.

If send a copy, then send a copy of all children, grandchildren etc.

DynamicWeakPtr used to hold parents and children, so can be any type of NetObject.

Actual NetObject type interface is responsible for returning the interface and invoker to use for this
NetObject. This removes the need for them to be transmitted over the network.

Can thus send a message saying, can you set up an invoker for object typeid,objid please?

Versioning is handled by the initial handshake when the nodes all log in together.

Master status can either be fixed or changed on request. This can be changed at any time, on
a per-netobject basis. Thus if power is changable, then processors can request to get the master status
from the master before writing to the netobject. If the master status is fixed, then they can't
ask for the master status, and will have to wait until it is given to them. The flexible master
system will be slightly slower (as master status will change a lot) but it will mean that the 
user will not really notice this implementation detail.

Also need to deal with threads. Design is not really thread safe at the moment (as I don't lock the 
pointer when I read the data). I could lock the object, but that would be horribly slow in the double loop.
I think that I will need to use a coarse lock on the simsystem so that there is a definite read mode and 
a definite write mode. Cannot change anything when reading the system, only when writing. This
will mean that I know that there are no PtrWriters operating during energy evaluations.

Problem is that there is no way to enfore this? Would be nice if I could lock the parent NetObject,
and this also locked all of the children, grandchildren etc.

Need concept of read lock and write lock... I will look into this later...
